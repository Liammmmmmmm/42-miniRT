void	hit_planes(inout hit_record hit, inout bool hit_something, vec3 ro, vec3 rd)
{
	uint	i = 0;

	while (i < planes_am)
	{
		hit_record hit_tmp = get_default_hit_record();
		if (hit_plane(planes[i], ro, rd, hit_tmp))
		{
			if (hit_tmp.t < hit.t)
			{
				hit_something = true;
				hit = hit_tmp;
				hit.object_type = 5;
				hit.object_index = i;
				hit.material_id = planes[i].material_id;
			}
		}
		i++;
	}
}

void	set_final_values(inout hit_record hit)
{
	if (hit.object_type == 0) // primitives
	{
		get_sphere_uv(hit, primitives[hit.object_index]);

		apply_all_map(hit);
		hit.color = get_hit_register_color(primitives[hit.object_index].color, hit);
	}
	else if (hit.object_type == 1) // cyl
	{
		if (hit.part_id == 0)
		{
			get_cylinder_lateral_uv(hit, primitives[hit.object_index]);
		}
		else if (hit.part_id == 1)
		{
			get_cylinder_cap_uv(hit, primitives[hit.object_index], 1);
		}
		else if (hit.part_id == 2)
		{
			get_cylinder_cap_uv(hit, primitives[hit.object_index], -1);
		}

		apply_all_map(hit);
		hit.color = get_hit_register_color(primitives[hit.object_index].color, hit);
	}
	else if (hit.object_type == 2) // cone
	{
		if (hit.part_id == 0)
		{
			get_cone_lateral_uv(hit, primitives[hit.object_index]);
		}
		else if (hit.part_id == 1)
		{
			get_cone_cap_uv(hit, primitives[hit.object_index]);
		}

		apply_all_map(hit);
		hit.color = get_hit_register_color(primitives[hit.object_index].color, hit);
	}
	if (hit.object_type == 3) // hyper
	{
		get_hyperboloid_uv(hit, hypers[hit.object_index]);

		apply_all_map(hit);
		hit.color = get_hit_register_color(hypers[hit.object_index].color, hit);
	}
	else if (hit.object_type == 4) // triangle
	{
		float u = hit.u;
		float v = hit.v;
		Triangle t = triangles[hit.object_index];
		
		float w = 1.0 - u - v;
		hit.normal = normalize(w * t.v0.normal + u * t.v1.normal + v * t.v2.normal);
		hit.front_face = true;
		hit.u = w * t.v0.u + u * t.v1.u + v * t.v2.u;
		hit.v = w * t.v0.v + u * t.v1.v + v * t.v2.v;

		apply_all_map(hit);
		hit.color = get_hit_register_color(triangles[hit.object_index].color, hit);
	}
	else if (hit.object_type == 5) // planes
	{
		get_uv_plane(hit, planes[hit.object_index]);

		apply_all_map(hit);
		hit.color = get_hit_register_color(planes[hit.object_index].color, hit);
	}
	
}

bool hit_register_all(inout hit_record hit, vec3 ro, vec3 rd, bool calc_uv)
{
	bool	hit_something = false;
	hit_something = hit_bvh(ro, rd, hit);
	hit_planes(hit, hit_something, ro, rd);

	if (calc_uv)
		set_final_values(hit);

	return (hit_something);
}

void hit_register_depth(inout hit_record hit, vec3 ro, vec3 rd)
{
	int		depth = -1;
	if (hit_bvh_depth(ro, rd, depth) == true)
		hit.color.x = float(depth);
}
