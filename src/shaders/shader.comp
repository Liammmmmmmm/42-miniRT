

bool hit_sphere(vec3 ro, vec3 rd, Sphere sphere)
{
	vec3 oc = ro - sphere.position;
	float a = dot(rd, rd);
	float b = 2.0 * dot(oc, rd);
	float c = dot(oc, oc) - sphere.radius * sphere.radius;
	float discriminant = b * b - 4.0 * a * c;
	return (discriminant > 0.0);
}

void	get_thread_seed()
{
	g_seed = uint(gl_GlobalInvocationID.x) * 1973u 
		* uint(gl_GlobalInvocationID.y) * 9277u 
		+ uint(sample_count) * 6541u;
	rand();
	rand();
}

void main() {
	uvec2 gid = gl_GlobalInvocationID.xy;
	if (gid.x >= width_render || gid.y >= height_render)
		return;

	uint id = gid.y * width_render + gid.x;

	get_thread_seed();

	vec3 ro;
	if (cam.defocus_angle <= 0)
		ro = cam.position;
	else
		ro = defocus_disk_sample(cam.position, viewport.defocus_disk_u, viewport.defocus_disk_v);

	vec3 pixel_pos = viewport.upper_left
		+ (float(gid.x) + rand() - 0.5) * viewport.pixel_delta_u
		+ (float(gid.y) + rand() - 0.5) * viewport.pixel_delta_v;

	vec3 rd = normalize(pixel_pos - ro);

	data[id] = path_trace(ro, rd);

	if (isnan(data[id].x) || isnan(data[id].y) || isnan(data[id].z))
		data[id] = vec3(0.0);

	// for (int i = 0; i < 3; ++i) {
	// 	if (hit_sphere(ro, rd, spheres[i])) {
	// 		data[id] = materials[spheres[i].material_id].color_value;
	// 		return;
	// 	}
	// }

	// data[id] = vec3(0.0, 0.0, 0.0); // noir sinon
}