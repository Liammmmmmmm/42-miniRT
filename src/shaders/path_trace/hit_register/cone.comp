
void	get_cone_lateral_uv(inout hit_record hit, Cone cone)
{
	vec3		right;
	const vec3	rel = hit.point - cone.position;

	if (abs(cone.orientation.y) < 0.99)
		right = normalize(cross(vec3(0.0, 1.0, 0.0), cone.orientation));
	else
		right = normalize(cross(vec3(1.0, 0.0, 0.0), cone.orientation));
	hit.u = clamp((atan(dot(rel, cross(cone.orientation, right)), dot(rel, right)) + PI) / (2.0 * PI), 0.0, 1.0);
	hit.v = clamp((dot(hit.point - cone.position, cone.orientation) / (cone.height)), 0.0, 1.0);
	if (hit.material_id != -1 && materials[hit.material_id].scale != 1)
	{
		hit.u *= materials[hit.material_id].scale;
		hit.v *= materials[hit.material_id].scale;
		hit.u = fract(hit.u);
		hit.v = fract(hit.v);
	}
}

void	get_cone_cap_uv(inout hit_record hit, Cone cone)
{
	vec3		right;
	const vec3	rel = hit.point - cone.position + cone.orientation * cone.height * 0.5;

	if (abs(cone.orientation.y) < 0.99)
		right = normalize(cross(vec3(0.0, 1.0, 0.0), cone.orientation));
	else
		right = normalize(cross(vec3(1.0, 0.0, 0.0), cone.orientation));
	hit.u = clamp((dot(rel, right) / cone.diameter) + 0.5, 0.0, 1.0);
	hit.v = clamp((dot(rel, cross(cone.orientation, right)) / cone.diameter) + 0.5, 0.0, 1.0);
	if (hit.material_id != -1 && materials[hit.material_id].scale != 1)
	{
		hit.u *= materials[hit.material_id].scale;
		hit.v *= materials[hit.material_id].scale;
		hit.u = fract(hit.u);
		hit.v = fract(hit.v);
	}
}

bool	handle_cone_hit(Cone cone, vec3 ro, vec3 rd, inout hit_record hit, quadratic q)
{
	const vec3	axis = normalize(cone.orientation);
	const vec3	p = ray_at(ro, rd, q.t_hit);
	const vec3	apex = cone.position;
	const float	proj = dot(p - apex, axis);
	vec3		normal;

	if (proj < 0.0 || proj > cone.height)
		return (false);
	normal = (p - apex - (axis * (1.0 + ((cone.diameter * 0.5 / cone.height) * (cone.diameter * 0.5 / cone.height))) * proj));
	normal = normalize(normal);
	hit.t = q.t_hit;
	hit.point = p;
	hit.normal = set_normal_face(ro, rd, normal, hit);
	hit.material_id = cone.material_id;
	get_cone_lateral_uv(hit, cone);
	return (true);
}

bool	cone_cap(Cone cone, vec3 ro, vec3 rd, inout hit_record hit)
{
	const vec3	cap_c = cone.position + normalize(cone.orientation) * cone.height;
	const vec3	normal = normalize(cone.orientation);
	const float	denom = dot(rd, normal);
	float		t;
	vec3		hit_point;

	if (abs(denom) < 1e-6)
		return (false);
	t = dot(cap_c - ro, normal) / denom;
	if (t < IT_MIN || t > IT_MAX)
		return (false);
	hit_point = ray_at(ro, rd, t);
	if (length(hit_point - cap_c) > (cone.diameter * 0.5))
		return (false);
	hit.t = t;
	hit.point = hit_point;
	hit.normal = normal;
	hit.front_face = dot(rd, hit.normal) < 0;
	hit.part_id = 1;
	hit.material_id = cone.material_id_top;
	if (hit.material_id == -1)
		hit.material_id = cone.material_id;
	get_cone_cap_uv(hit, cone);
	return (true);
}

bool	init_cone_quadratic(inout quadratic q, Cone cone, vec3 ro, vec3 rd)
{
	const vec3	oc = ro - cone.position;
	const float	k = pow((cone.diameter * 0.5) / cone.height, 2.0);

	q.dd = dot(rd, cone.orientation);
	q.oo = dot(oc, cone.orientation);
	q.a = dot(rd, rd) - (1.0 + k) * q.dd * q.dd;
	q.b = 2.0 * (dot(rd, oc) - (1.0 + k) * q.dd * q.oo);
	q.c = dot(oc, oc) - (1.0 + k) * q.oo * q.oo;
	return (solve_quadratic(q));
}

bool	hit_cone(Cone cone, vec3 ro, vec3 rd, out hit_record hit)
{
	quadratic	q = get_default_quadratic();
	bool		hit_cap;

	if (cone.orientation.x == 0 && cone.orientation.y == 0 && cone.orientation.z == 0)
		cone.orientation.y = 1;
	if (!init_cone_quadratic(q, cone, ro, rd) || !valid_t(q))
		return (false);
	if (handle_cone_hit(cone, ro, rd, hit, q))
		return (true);
	hit_cap = cone_cap(cone, ro, rd, hit);
	if (!hit_cap)
		return (false);
	hit.front_face = dot(rd, hit.normal) < 0;
	hit.normal = set_normal_face(ro, rd, hit.normal, hit);
	return (true);
}
