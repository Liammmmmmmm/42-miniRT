
vec3 cos_weighted_sample_hemishphere(vec3 normal)
{
	vec2	r = vec2(rand(), rand());
	float	phi = 2.0 * PI * r.x;

	vec3 local_dir;
	local_dir.x = cos(phi) * sqrt(r.y);
	local_dir.y = sqrt(1 - r.y);
	local_dir.z = sin(phi) * sqrt(r.y);

	vec3 tangent = normalize(abs(normal.y) < 0.999 ? cross(vec3(0, 1, 0), normal) : cross(vec3(1, 0, 0), normal));
	vec3 bitangent = cross(normal, tangent);
	local_dir = tangent * local_dir.x + normal * local_dir.y + bitangent * local_dir.z;

	return (normalize(local_dir));
}


void	importance_sampling(vec3 ro, inout vec3 rd, hit_record hit, inout vec3 power, inout vec3 accumulation)
{
	hit_record	tmp_hit = get_default_hit_record();
	const vec2	uv = calc_inverse_transform_sampling_uv();
	vec3		radiance;

	rd = calc_inverse_transform_sampling_dir(uv);
	if (hit_register_all(tmp_hit, ro, rd, false))
		return ;
	float costheta = dot(hit.normal, rd);
	float pdf = texture(pdf_joint, uv).r;
	if (pdf <= 0)
		return ;
	radiance = get_background_color(rd);
	if (hit.material_id != -1)
		radiance *= hit.mat_val.ao;
	radiance *= power;
	radiance *= costheta / pdf;
	accumulation += radiance;
	power *= (1.0 - costheta);
}

void	material_default(inout vec3 ro, inout vec3 rd, hit_record hit, inout vec3 power, inout vec3 accumulation)
{
	vec3	direct_lighting = compute_light(hit);
	vec3	caustics_lighting = vec3(0.0); // get_caustic(hit);

	power *= hit.color;
	accumulation += (direct_lighting + caustics_lighting) * power;

	if (ambiant.skybox_tex_index != -1)
		importance_sampling(ro + hit.normal * 0.01, rd, hit, power, accumulation);

	rd = cos_weighted_sample_hemishphere(hit.normal);
}
