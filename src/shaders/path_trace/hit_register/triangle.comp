bool hit_triangle(Triangle t, vec3 ro, vec3 rd, inout hit_record hit)
{
    // Vecteurs des arêtes du triangle
    vec3 e1 = t.v1.pos - t.v0.pos;
    vec3 e2 = t.v2.pos - t.v0.pos;

    // Calcule le déterminant
    vec3 h = cross(rd, e2);
    float a = dot(e1, h);

    // Optimisation: Back-face culling
    // Rejette les triangles qui tournent le dos au rayon ET les rayons parallèles.
    // C'est plus rapide que d'utiliser abs(a).
    if (a <= 1e-6)
        return false;

    float f = 1.0 / a;
    vec3 s = ro - t.v0.pos;
    float u = f * dot(s, h);

    // Le point d'intersection est en dehors des limites du triangle
    if (u < 0.0 || u > 1.0)
        return false;

    vec3 q = cross(s, e1);
    float v = f * dot(rd, q);

    // Le point d'intersection est en dehors des limites du triangle
    if (v < 0.0 || u + v > 1.0)
        return false;

    // Calcule 't', la distance jusqu'au point d'intersection
    float hit_t = f * dot(e2, q);

    // Vérifie si ce triangle est plus proche que le précédent hit
    if (hit_t > 1e-4 && hit_t < hit.t)
    {
        // Met à jour le hit_record avec les nouvelles informations
        hit.t = hit_t;
        hit.point = ro + rd * hit_t;

        // Interpolation des attributs avec les coordonnées barycentriques (u, v)
        float w = 1.0 - u - v;
        vec3 outward_normal = w * t.v0.normal + u * t.v1.normal + v * t.v2.normal;
        hit.normal = normalize(outward_normal); // La normale pointe déjà vers l'extérieur grâce au culling
        hit.front_face = true;

        hit.u = w * t.v0.u + u * t.v1.u + v * t.v2.u;
        hit.v = w * t.v0.v + u * t.v1.v + v * t.v2.v;

        return true;
    }

    return false;
}