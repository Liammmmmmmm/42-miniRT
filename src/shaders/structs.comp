#version 430

// Suggestion pour la nomenclature :
// tout ce qui est objet on le met en PascalCase
// le reste (juste stocker de la data) on reste en mode snake case normal

struct Camera {
	vec3 position;
	float fov;
	vec3 orientation;
	float focus_dist;
	float defocus_angle;
};

struct Sphere {
	vec3 position;
	float radius;
	vec3 color;
	int material_id;
};

struct Plane {
	vec3 position;
	int material_id;
	vec3 normal;
	float d;
	vec3 color;
};

struct Hyper {
	vec3	position;
	int material_id;
	vec3 orientation;
	float	height;
	vec3	color;
	float	a;
	float	b;
	float	c;
	float	shape;
};

struct	Cone {
	vec3	position;
	int material_id;
	vec3 orientation;
	float	diameter;
	vec3	color;
	float	height;
	int material_id_top;
};

struct	Cylinder {
	vec3	position;
	int material_id;
	vec3 orientation;
	float	diameter;
	vec3	color;
	float	height;
	int material_id_top;
	int material_id_bot;
};

struct Moller {
	vec3	e1;
	vec3	e2;
	vec3	h;
	vec3	s;
	vec3	q;
	float	f;
	float	u;
	float	v;
	float	t;
};

struct	Vertex {
	vec3	pos;
	float	u;
	vec3	normal;
	float	v;
};

struct	Triangle {
	Vertex	v0;
	Vertex	v1;
	Vertex	v2;
	vec3		color;
	int			material_id;
	vec3		center;
	int			obj_id;
};

struct Viewport {
	vec3	u;
	float	focal_length;
	vec3	v;
	float	height;
	vec3	pixel_delta_u;
	float	width;
	vec3	pixel_delta_v;
	int		render_w;
	vec3	upper_left;
	int		render_h;
	vec3	pixel00_loc;
	float	gamma;
	vec3	defocus_disk_u;
	float	defocus_radius;
	vec3	defocus_disk_v;
	int		max_bounces;
	float	ior_global;
};

struct Ambiant {
	vec3	skybox_color;
	float	ratio;
	int		skybox_tex_index;
};

struct Light {
	vec3	pos;
	int		type;
	vec3	color;
	float	brightness;
	float	radius;
	uint	shadow_sample;
};

struct Material {
	vec3	color_value;
	int		color_tex_index;
	float	metallic_value;
	int		metallic_tex_index;
	float	roughness_value;
	int		roughness_tex_index;
	float	ior;
	float	transmission_value;
	int		transmission_tex_index;
	float	ao_value;
	int		ao_tex_index;
	float	emission_strength;
	int		emission_strength_tex_index;
	float	scale;
	vec3	emission_color;
	int		emission_color_tex_index;
	int		normal_tex_index;
	float	normal_intensity;
};

struct MaterialValues {
	float	metallic;
	float	roughness;
	float	ior;
	float	transmission;
	float	ao;
	float	emission_strength;
	float	scale;
	float	normal_intensity;
	vec3	emission_color;
};

struct Checker {
	vec3	c1;
	float	scale;
	vec3	c2;
};

struct TextureData {
	uint	width;
	uint	height;
	uint	offset;
	float	exposure;
};

struct type_indice
{
	uint	type;
	uint	indice;
};

struct hit_record
{
	vec3			point;
	float			t;
	vec3			normal;
	int				material_id;
	vec3			color;
	bool			front_face;
	uint			object_index;
	uint			object_type;
	float			u;
	float			v;
	int				part_id;
	MaterialValues	mat_val;
};

hit_record	get_default_hit_record()
{
	return hit_record(
		vec3(0),
		10000000.0,
		vec3(0),
		-1,
		vec3(0),
		false,
		0,
		0,
		0.0,
		0.0,
		0,
		MaterialValues(
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			vec3(0)
		)
	);
}

struct quadratic
{
	float	a;
	float	b;
	float	c;
	float	disc;
	float	t0;
	float	t1;
	float	t_hit;
	float	t_hit2;
	float	dd;
	float	oo;
};

quadratic	get_default_quadratic()
{
	return quadratic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
}

struct	aabb
{
	vec3	min;
	vec3	max;
};

struct	bvh_node
{
	aabb	node_bounds;
  uint  left_child;
	uint  right_child;
	uint	first_prim;
	uint	prim_count;
	bool	is_leaf;
};
