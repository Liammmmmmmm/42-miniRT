void	get_thread_seed()
{
	g_seed = uint(gl_GlobalInvocationID.x + 1) * 1973u 
		* uint(gl_GlobalInvocationID.y + 1) * 9277u 
		+ uint(sample_count + 1) * 6541u;
	rand();
	rand();
}

void main() {
	uvec2 gid = gl_GlobalInvocationID.xy;
	if (gid.x >= width_render || gid.y >= height_render)
		return;

	get_thread_seed();

	uint id = gid.y * width_render + gid.x;

	// data[id] = vec3(1.0, 0.5, 0.2);
	// return ;

	// vec4 tex = sample_texture(0, vec2(float(gid.x) / width_render, float(gid.y) / height_render));
	// data[id] = vec3(tex.x, tex.y, tex.z);
	// data[id] = vec3(sample_count == 0);
	// return ;
	// data[id] = vec3(texture(pdf_joint, vec2(float(gid.x) / width_render, float(gid.y) / height_render)).r);
	// return ;
	

	// vec2 test = calc_inverse_transform_sampling_uv();
	// id = uint((1 - test.y) * (height_render - 1)) * width_render + uint(test.x * (width_render - 1));
	// data[id] += vec3(0.1);
	// return ;

	// if (gid.x < width_render / 2)
	// else
	// data[id] = vec3(table_size == 0);
	// return ;

	vec3 ro;
	if (cam.defocus_angle <= 0)
		ro = cam.position;
	else
		ro = defocus_disk_sample(cam.position, viewport.defocus_disk_u, viewport.defocus_disk_v);

	vec3 pixel_pos = viewport.upper_left
		+ (float(gid.x) + rand() - 0.5) * viewport.pixel_delta_u
		+ (float(gid.y) + rand() - 0.5) * viewport.pixel_delta_v;

	vec3 rd = normalize(pixel_pos - ro);

	if (render_mode == 0)
		data[id] = path_trace(ro, rd);
	else if (render_mode == 1)
		data[id] = path_trace_bvh(ro, rd);
	else if (render_mode == 2)
		data[id] = path_trace_normal(ro, rd);
	// data[id] = vec3(ambiant.skybox_tex_index);
	// if (viewport.t_one_sided == 1)
	// 	data[id] = vec3(1.0);
	// else
	// 	data[id] = vec3(0.0);

	if (isnan(data[id].x) || isnan(data[id].y) || isnan(data[id].z))
		data[id] = vec3(0.0);
}
